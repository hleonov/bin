#!/usr/bin/perl

# don't forget to convert the segid using xplortopdb.pl first!!!!!

# the objective of this script is to take a transmembrane
# helical bundle generated by chi and place the N- and
# C-terminal caps as their own residues, and changing
# the atom specifications.
# the script won't work if the resid of the first residue is 1.


# this loop will store all of the info
while(<>){
  if(!/^ATOM/ && !/^TER/ && !/^END/){
    $remark .= $_;
  }
  
  if(/^ATOM.{7}(.{6})(.{3})(.{2})(.{4})(.+)/){
    $i++;
    $new_chain[$i] = $3;
    # it is a new chain id
    if($new_chain[$i] ne $new_chain[$i-1]){ 
      $segid++;
    }
    $atom[$segid][$i] = $1;
    $res[$segid][$i] = $2;
    $chain[$segid][$i] = $3;
    $number[$segid][$i] = $4;
    $rest[$segid][$i] = $5;
    # grab the caps
    if("  CM  " eq $1){
      $cm[$segid] = $5;
    }
    elsif("  C3  " eq $1){
      $c3[$segid] = $5;
    }
    elsif("  OM  " eq $1){
      $om[$segid] = $5;
    }
    elsif("  NT  " eq $1){
      $nt[$segid] = $5;
    }
    elsif("  CT  " eq $1){
      $ct[$segid] = $5;
    }
    elsif("  HT  " eq $1){
      $ht[$segid] = $5;
    }
  }
  if(/^TER/ || /^END/){ # zero the atom counter
    $last[$segid] = $number[$segid][$i]; # remember the bigest res id
    $atoms[$segid] = $i;
    $i = 0;
  }
}
print $remark;
# now run through every chain
# remember that the segid and number start at 1 and not 0
for($i = 1; $i <= $segid; $i++){
  # figure out the numbering of the residues and clean it up
  $first = $number[1][1];
  $last = $last[$i];
  $first =~ s/\s//g;
  $last =~ s/\s//g;
  $first -= 1;
  $last += 1;
  $total_atom_count++;
  # first print the N-terminal cap
  # the c3
  print "ATOM";
  printf ("%7.0f",$total_atom_count);
  print "  CA  ACE";
  print $chain[$i][2];
  printf ("%4.0f",$first);
  print $c3[$i];
  print "\n";
  $total_atom_count++;
  # the cm
  print "ATOM";
  printf ("%7.0f",$total_atom_count);
  print "  C   ACE";
  print $chain[$i][2];
  printf ("%4.0f",$first);
  print $cm[$i];
  print "\n";
  $total_atom_count++;
  # the om
  print "ATOM";
  printf ("%7.0f",$total_atom_count);
  print "  O   ACE";
  print $chain[$i][2];
  printf ("%4.0f",$first);
  print $om[$i];
  print "\n";
  $total_atom_count++;
  # now print the normal atoms
  for($j = 1; $j <= $atoms[$i]; $j++){
    # not the caps
    unless($atom[$i][$j] eq "  C3  " || $atom[$i][$j] eq "  CM  " || $atom[$i][$j] eq "  OM  " || $atom[$i][$j] eq "  NT  " || $atom[$i][$j] eq "  CT  " || $atom[$i][$j] eq "  HT  "){
      print "ATOM";
      printf ("%7.0f",$total_atom_count);
      print "$atom[$i][$j]";
      print "$res[$i][$j]";
      print $chain[$i][$j];
      printf ("%4.0f",$number[$i][$j]);
      print "$rest[$i][$j]";
      print "\n";
      $total_atom_count++;
    }
  }
  # now print the C-terminal cap
  # the nt
  print "ATOM";
  printf ("%7.0f",$total_atom_count);
  print "  N   NAC";
  print $chain[$i][2];
  printf ("%4.0f",$last);
  print $nt[$i];
  print "\n";
  $total_atom_count++;
  # the ct
  print "ATOM";
  printf ("%7.0f",$total_atom_count);
  print "  CA  NAC";
  print $chain[$i][2];
  printf ("%4.0f",$last);
  print $ct[$i];
  print "\n";
  #$total_atom_count++;
  # the ht atom is not needed since gromacs puts it back
  #print "ATOM";
  #printf ("%7.0f",$total_atom_count);
  #print "  HT  NAC";
  #print $chain[$i][2];
  #printf ("%4.0f",$last);
  #print $ht[$i];
  #print "\n";
  # print the chain termination signs
  if($i < $segid){
    print "TER\n";
  }
  else{
    print "END\n";
  }
}













